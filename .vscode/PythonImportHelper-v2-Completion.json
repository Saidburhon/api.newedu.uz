[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BackgroundTasks",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "status",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "EmailStr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "TIMESTAMP",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "func",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UniqueConstraint",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Index",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "create_engine",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Column",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Integer",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "String",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Boolean",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "TIMESTAMP",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "ForeignKey",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "UniqueConstraint",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "Index",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "text",
        "importPath": "sqlalchemy",
        "description": "sqlalchemy",
        "isExtraImport": true,
        "detail": "sqlalchemy",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "sessionmaker",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "Session",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "relationship",
        "importPath": "sqlalchemy.orm",
        "description": "sqlalchemy.orm",
        "isExtraImport": true,
        "detail": "sqlalchemy.orm",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "CryptContext",
        "importPath": "passlib.context",
        "description": "passlib.context",
        "isExtraImport": true,
        "detail": "passlib.context",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordBearer",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "OAuth2PasswordRequestForm",
        "importPath": "fastapi.security",
        "description": "fastapi.security",
        "isExtraImport": true,
        "detail": "fastapi.security",
        "documentation": {}
    },
    {
        "label": "declarative_base",
        "importPath": "sqlalchemy.ext.declarative",
        "description": "sqlalchemy.ext.declarative",
        "isExtraImport": true,
        "detail": "sqlalchemy.ext.declarative",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "jwt",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jwt",
        "description": "jwt",
        "detail": "jwt",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)\n    age = Column(Integer, nullable=False)\n    email = Column(String(255), unique=True)\n    password_hash = Column(String(255), nullable=False)\n    created_at = Column(TIMESTAMP, server_default=func.current_timestamp())\n    updated_at = Column(TIMESTAMP, server_default=func.current_timestamp(),",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "BlockedApp",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class BlockedApp(Base):\n    __tablename__ = \"blocked_apps\"\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    package_name = Column(String(255), nullable=False)\n    app_name = Column(String(255), nullable=False)\n    is_blocked = Column(Boolean, default=True)\n    created_at = Column(TIMESTAMP, server_default=func.current_timestamp())\n    updated_at = Column(TIMESTAMP, server_default=func.current_timestamp(),\n                        onupdate=func.current_timestamp())",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "RegisterRequest",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class RegisterRequest(BaseModel):\n    username: str = Field(..., min_length=6)\n    phone_number: str\n    age: int\n    email: EmailStr = None\n    @validator(\"phone_number\")\n    def validate_phone_number(cls, v):\n        if not v.startswith(\"+998\"):\n            raise ValueError(\"Phone number must start with +998\")\n        return v",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "OTPVerification",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class OTPVerification(BaseModel):\n    phone_number: str\n    otp: str\n    @validator(\"phone_number\")\n    def validate_phone_number(cls, v):\n        if not v.startswith(\"+998\"):\n            raise ValueError(\"Phone number must start with +998\")\n        return v\nclass SetPassword(BaseModel):\n    phone_number: str",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "SetPassword",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class SetPassword(BaseModel):\n    phone_number: str\n    password: str = Field(..., min_length=6)\nclass LoginRequest(BaseModel):\n    username: str\n    password: str\nclass BlockedAppCreate(BaseModel):\n    user_id: int\n    package_name: str\n    app_name: str",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "LoginRequest",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class LoginRequest(BaseModel):\n    username: str\n    password: str\nclass BlockedAppCreate(BaseModel):\n    user_id: int\n    package_name: str\n    app_name: str\nclass BlockedAppUpdate(BaseModel):\n    is_blocked: bool\n# -----------------------------",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "BlockedAppCreate",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class BlockedAppCreate(BaseModel):\n    user_id: int\n    package_name: str\n    app_name: str\nclass BlockedAppUpdate(BaseModel):\n    is_blocked: bool\n# -----------------------------\n# Password Hashing Utility\n# -----------------------------\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "BlockedAppUpdate",
        "kind": 6,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "class BlockedAppUpdate(BaseModel):\n    is_blocked: bool\n# -----------------------------\n# Password Hashing Utility\n# -----------------------------\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\ndef verify_password(plain_password, hashed_password) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "hash_password",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def hash_password(password: str) -> str:\n    return pwd_context.hash(password)\ndef verify_password(plain_password, hashed_password) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n# -----------------------------\n# OTP Handling (Simple in-memory store)\n# -----------------------------\n# In production, use a persistent store or cache (like Redis)\notp_store = {}  # mapping phone_number -> (otp, timestamp, registration_data)\nOTP_EXPIRY_SECONDS = 300  # OTP valid for 5 minutes",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def verify_password(plain_password, hashed_password) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n# -----------------------------\n# OTP Handling (Simple in-memory store)\n# -----------------------------\n# In production, use a persistent store or cache (like Redis)\notp_store = {}  # mapping phone_number -> (otp, timestamp, registration_data)\nOTP_EXPIRY_SECONDS = 300  # OTP valid for 5 minutes\n# -----------------------------\n# Helper function for sending SMS (dummy)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "send_sms",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def send_sms(phone_number: str, message: str):\n    # Integrate with an SMS service provider in production\n    print(f\"Sending SMS to {phone_number}: {message}\")\n# -----------------------------\n# Dependency: DB Session\n# -----------------------------\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n# -----------------------------\n# FastAPI App Instance\n# -----------------------------\napp = FastAPI(title=\"Unified API for Mobile & Web\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "register_user",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def register_user(reg: RegisterRequest, background_tasks: BackgroundTasks):\n    otp = ''.join(random.choices(string.digits, k=6))\n    # Store registration details and OTP in the otp_store\n    otp_store[reg.phone_number] = (otp, time.time(), reg.model_dump())\n    message = f\"Your OTP is {otp}\"\n    background_tasks.add_task(send_sms, reg.phone_number, message)\n    return {\"message\": \"OTP sent to phone number\"}\n# Registration: Step 2 - Verify OTP\n@app.post(\"/verify-otp\")\ndef verify_otp(data: OTPVerification):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "verify_otp",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def verify_otp(data: OTPVerification):\n    record = otp_store.get(data.phone_number)\n    if not record:\n        raise HTTPException(status_code=400, detail=\"OTP not requested\")\n    otp, timestamp, _ = record\n    if time.time() - timestamp > OTP_EXPIRY_SECONDS:\n        del otp_store[data.phone_number]\n        raise HTTPException(status_code=400, detail=\"OTP expired\")\n    if otp not in [data.otp, 7007]:\n        raise HTTPException(status_code=400, detail=\"Invalid OTP\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "set_password",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def set_password(data: SetPassword, db: Session = Depends(get_db)):\n    record = otp_store.get(data.phone_number)\n    if not record:\n        raise HTTPException(status_code=400, detail=\"OTP verification required\")\n    _, _, reg_data = record\n    # Remove OTP record once used\n    del otp_store[data.phone_number]\n    # Hash the password\n    reg_data[\"password_hash\"] = hash_password(data.password)\n    # Create the user in the database",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def login(data: LoginRequest, db: Session = Depends(get_db)):\n    user = db.query(User).filter(User.username == data.username).first()\n    if not user or not verify_password(data.password, user.password_hash):\n        raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n    # In production, generate and return a JWT token or session cookie\n    return {\"message\": \"Login successful\", \"user_id\": user.id}\n# -----------------------------\n# Blocked Apps Endpoints\n# -----------------------------\n# GET /blocked-apps?user_id=X",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "get_blocked_apps",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def get_blocked_apps(user_id: int, db: Session = Depends(get_db)):\n    apps = db.query(BlockedApp).filter(BlockedApp.user_id == user_id).all()\n    return apps\n# POST /blocked-apps\n@app.post(\"/blocked-apps\")\ndef create_blocked_app(app_data: BlockedAppCreate, db: Session = Depends(get_db)):\n    blocked_app = BlockedApp(**app_data.dict())\n    db.add(blocked_app)\n    try:\n        db.commit()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "create_blocked_app",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def create_blocked_app(app_data: BlockedAppCreate, db: Session = Depends(get_db)):\n    blocked_app = BlockedApp(**app_data.dict())\n    db.add(blocked_app)\n    try:\n        db.commit()\n        db.refresh(blocked_app)\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=\"Could not create blocked app (possible duplicate)\")\n    return blocked_app",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "update_blocked_app",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def update_blocked_app(id: int, update_data: BlockedAppUpdate, db: Session = Depends(get_db)):\n    blocked_app = db.query(BlockedApp).filter(BlockedApp.id == id).first()\n    if not blocked_app:\n        raise HTTPException(status_code=404, detail=\"Blocked app not found\")\n    blocked_app.is_blocked = update_data.is_blocked\n    try:\n        db.commit()\n        db.refresh(blocked_app)\n    except Exception as e:\n        db.rollback()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "delete_blocked_app",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def delete_blocked_app(id: int, db: Session = Depends(get_db)):\n    blocked_app = db.query(BlockedApp).filter(BlockedApp.id == id).first()\n    if not blocked_app:\n        raise HTTPException(status_code=404, detail=\"Blocked app not found\")\n    db.delete(blocked_app)\n    db.commit()\n    return {\"message\": \"Blocked app deleted\"}\n# -----------------------------\n# Security Note on API Keys\n# -----------------------------",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "DATABASE_URL = os.environ.get(\"DATABASE_URL\", \"mysql+pymysql://user:password@localhost/dbname\")\nprint(f\"Database URL: {DATABASE_URL}\")\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "engine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)\n    age = Column(Integer, nullable=False)\n    email = Column(String(255), unique=True)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)\n    age = Column(Integer, nullable=False)\n    email = Column(String(255), unique=True)\n    password_hash = Column(String(255), nullable=False)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "Base = declarative_base()\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)\n    age = Column(Integer, nullable=False)\n    email = Column(String(255), unique=True)\n    password_hash = Column(String(255), nullable=False)\n    created_at = Column(TIMESTAMP, server_default=func.current_timestamp())",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\ndef verify_password(plain_password, hashed_password) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n# -----------------------------\n# OTP Handling (Simple in-memory store)\n# -----------------------------\n# In production, use a persistent store or cache (like Redis)\notp_store = {}  # mapping phone_number -> (otp, timestamp, registration_data)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "otp_store",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "otp_store = {}  # mapping phone_number -> (otp, timestamp, registration_data)\nOTP_EXPIRY_SECONDS = 300  # OTP valid for 5 minutes\n# -----------------------------\n# Helper function for sending SMS (dummy)\n# -----------------------------\ndef send_sms(phone_number: str, message: str):\n    # Integrate with an SMS service provider in production\n    print(f\"Sending SMS to {phone_number}: {message}\")\n# -----------------------------\n# Dependency: DB Session",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "OTP_EXPIRY_SECONDS",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "OTP_EXPIRY_SECONDS = 300  # OTP valid for 5 minutes\n# -----------------------------\n# Helper function for sending SMS (dummy)\n# -----------------------------\ndef send_sms(phone_number: str, message: str):\n    # Integrate with an SMS service provider in production\n    print(f\"Sending SMS to {phone_number}: {message}\")\n# -----------------------------\n# Dependency: DB Session\n# -----------------------------",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "app = FastAPI(title=\"Unified API for Mobile & Web\")\n# -----------------------------\n# Endpoints\n# -----------------------------\n# Registration: Step 1 - Request OTP\n@app.post(\"/register\")\ndef register_user(reg: RegisterRequest, background_tasks: BackgroundTasks):\n    otp = ''.join(random.choices(string.digits, k=6))\n    # Store registration details and OTP in the otp_store\n    otp_store[reg.phone_number] = (otp, time.time(), reg.model_dump())",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "User",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)  # adjust the format/length as needed\n    age = Column(Integer, nullable=False)\n    gender = Column(String(20), nullable=True)  # added as per your requirements; can be null if not provided\n    email = Column(String(255), unique=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    created_at = Column(TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"))",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "BlockedApp",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class BlockedApp(Base):\n    __tablename__ = \"blocked_apps\"\n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    package_name = Column(String(255), nullable=False)\n    app_name = Column(String(255), nullable=False)\n    is_blocked = Column(Boolean, default=True)\n    created_at = Column(TIMESTAMP, server_default=text(\"CURRENT_TIMESTAMP\"))\n    updated_at = Column(\n        TIMESTAMP, ",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "UserCreate",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class UserCreate(BaseModel):\n    username: str\n    phone_number: str\n    age: int\n    gender: str | None = None  # gender is optional\n    email: EmailStr\n    password: str\nclass UserResponse(BaseModel):\n    id: int\n    username: str",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "UserResponse",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class UserResponse(BaseModel):\n    id: int\n    username: str\n    phone_number: str\n    age: int\n    gender: str | None = None\n    email: EmailStr\n    created_at: datetime\n    updated_at: datetime\n    class Config:",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "Token",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class Token(BaseModel):\n    access_token: str\n    token_type: str\nclass BlockedAppCreate(BaseModel):\n    package_name: str\n    app_name: str\nclass BlockedAppResponse(BaseModel):\n    id: int\n    user_id: int\n    package_name: str",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "BlockedAppCreate",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class BlockedAppCreate(BaseModel):\n    package_name: str\n    app_name: str\nclass BlockedAppResponse(BaseModel):\n    id: int\n    user_id: int\n    package_name: str\n    app_name: str\n    is_blocked: bool\n    created_at: datetime",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "BlockedAppResponse",
        "kind": 6,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "class BlockedAppResponse(BaseModel):\n    id: int\n    user_id: int\n    package_name: str\n    app_name: str\n    is_blocked: bool\n    created_at: datetime\n    updated_at: datetime\n    class Config:\n        orm_mode = True",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "verify_password",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    expire = datetime.now() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "get_password_hash",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    expire = datetime.now() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n# ---------------------------\n# Dependency for Database Session",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "create_access_token",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    expire = datetime.now() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n# ---------------------------\n# Dependency for Database Session\n# ---------------------------\ndef get_db():",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "get_db",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n# ---------------------------\n# Dependency: Get Current User\n# ---------------------------\ndef get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> User:",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "get_current_user",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        user_id: str = payload.get(\"sub\")\n        if user_id is None:",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def register(user: UserCreate, db: Session = Depends(get_db)):\n    # Check if the email already exists\n    if db.query(User).filter(User.email == user.email).first():\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    hashed_password = get_password_hash(user.password)\n    new_user = User(\n        username=user.username,\n        phone_number=user.phone_number,\n        age=user.age,\n        gender=user.gender,",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "login",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):\n    # Here form_data.username is expected to be the email address.\n    user = db.query(User).filter(User.email == form_data.username).first()\n    if not user or not verify_password(form_data.password, user.password_hash):\n        raise HTTPException(status_code=400, detail=\"Incorrect email or password\")\n    access_token = create_access_token(data={\"sub\": str(user.id)})\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n# Get the list of blocked apps for the current user\n@app.get(\"/blocked_apps\", response_model=list[BlockedAppResponse])\ndef get_blocked_apps(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "get_blocked_apps",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def get_blocked_apps(current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):\n    apps = db.query(BlockedApp).filter(BlockedApp.user_id == current_user.id).all()\n    return apps\n# Add a new blocked app for the current user\n@app.post(\"/blocked_apps\", response_model=BlockedAppResponse)\ndef add_blocked_app(blocked_app: BlockedAppCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):\n    # Check if this app is already blocked for the user\n    if db.query(BlockedApp).filter(\n        BlockedApp.user_id == current_user.id,\n        BlockedApp.package_name == blocked_app.package_name",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "add_blocked_app",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def add_blocked_app(blocked_app: BlockedAppCreate, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):\n    # Check if this app is already blocked for the user\n    if db.query(BlockedApp).filter(\n        BlockedApp.user_id == current_user.id,\n        BlockedApp.package_name == blocked_app.package_name\n    ).first():\n        raise HTTPException(status_code=400, detail=\"App already in blocked list\")\n    new_app = BlockedApp(\n        user_id=current_user.id,\n        package_name=blocked_app.package_name,",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "remove_blocked_app",
        "kind": 2,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "def remove_blocked_app(package_name: str, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):\n    app_to_remove = db.query(BlockedApp).filter(\n        BlockedApp.user_id == current_user.id,\n        BlockedApp.package_name == package_name\n    ).first()\n    if not app_to_remove:\n        raise HTTPException(status_code=404, detail=\"Blocked app not found\")\n    db.delete(app_to_remove)\n    db.commit()\n    return {\"detail\": \"Blocked app removed successfully\"}",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "DATABASE_URL",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "DATABASE_URL = \"mysql+pymysql://pro100a1_new_edu:1globalNew-Edu@pro100a1.beget.tech/pro100a1_new_edu\"  # update with your MySQL credentials\nSECRET_KEY = os.getenv('SECRET_KEY')  # update with a secure secret key\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n# ---------------------------\n# Database Setup\n# ---------------------------\nengine = create_engine(\n    DATABASE_URL,\n    pool_recycle=3600,  # Recycle connections after 1 hour",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "SECRET_KEY",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "SECRET_KEY = os.getenv('SECRET_KEY')  # update with a secure secret key\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n# ---------------------------\n# Database Setup\n# ---------------------------\nengine = create_engine(\n    DATABASE_URL,\n    pool_recycle=3600,  # Recycle connections after 1 hour\n    pool_pre_ping=True, # Enable connection health checks",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "ALGORITHM",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "ALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n# ---------------------------\n# Database Setup\n# ---------------------------\nengine = create_engine(\n    DATABASE_URL,\n    pool_recycle=3600,  # Recycle connections after 1 hour\n    pool_pre_ping=True, # Enable connection health checks\n    pool_size=5,        # Maximum connections in pool",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "ACCESS_TOKEN_EXPIRE_MINUTES",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "ACCESS_TOKEN_EXPIRE_MINUTES = 30\n# ---------------------------\n# Database Setup\n# ---------------------------\nengine = create_engine(\n    DATABASE_URL,\n    pool_recycle=3600,  # Recycle connections after 1 hour\n    pool_pre_ping=True, # Enable connection health checks\n    pool_size=5,        # Maximum connections in pool\n    max_overflow=10     # Maximum overflow connections",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "engine",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "engine = create_engine(\n    DATABASE_URL,\n    pool_recycle=3600,  # Recycle connections after 1 hour\n    pool_pre_ping=True, # Enable connection health checks\n    pool_size=5,        # Maximum connections in pool\n    max_overflow=10     # Maximum overflow connections\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n# ---------------------------",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "SessionLocal",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n# ---------------------------\n# SQLAlchemy Models\n# ---------------------------\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)  # adjust the format/length as needed",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "Base",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "Base = declarative_base()\n# ---------------------------\n# SQLAlchemy Models\n# ---------------------------\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(255), nullable=False)\n    phone_number = Column(String(50), nullable=False)  # adjust the format/length as needed\n    age = Column(Integer, nullable=False)",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "pwd_context",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/login\", scheme_name=\"Bearer Token\")\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    expire = datetime.now() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "oauth2_scheme",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/login\", scheme_name=\"Bearer Token\")\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\ndef create_access_token(data: dict, expires_delta: timedelta | None = None):\n    to_encode = data.copy()\n    expire = datetime.now() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)",
        "detail": "test_api",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "test_api",
        "description": "test_api",
        "peekOfCode": "app = FastAPI()\n# ---------------------------\n# API Endpoints\n# ---------------------------\n# User Registration Endpoint\n@app.post(\"/register\", response_model=UserResponse)\ndef register(user: UserCreate, db: Session = Depends(get_db)):\n    # Check if the email already exists\n    if db.query(User).filter(User.email == user.email).first():\n        raise HTTPException(status_code=400, detail=\"Email already registered\")",
        "detail": "test_api",
        "documentation": {}
    }
]